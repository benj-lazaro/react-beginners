Building ExpenseFilter
----------------------
- The next component to build for the mini-project "Expense Tracker" is the <ExpenseFilter /> component
    - This component is solely responsible for showing category filters

    - NOTE: The act of filtering is one on the <App /> component (App.tsx)
        - This is the component that maintains the state

        - When the user selects a "category" filter in the <ExpenseFilter /> component
            - It notifies the <App /> component

            - The <App /> component performs the act of filtering the dummy data
                - Then rendering them on the DOM


- Open the folder "src/expense-list"
    - Create a new file named "ExpenseFilter.tsx"


- Inside the file "ExpenseFilter.tsx"
    - Use the shortcut "rafce" to generate component function boilerplate

    - On the component's JSX mark-up
        - Remove the JSX element <div>

        - Replace it with a JSX element <select> 
            - Declare the property "className"
            - Assign Bootstrap's class "form-select"

            const ExpenseFilter = () => {
                return <select name="" id="" className="form-select"></select>;
            };

        - Remove the properties "id" and "name"

            const ExpenseFilter = () => {
                return <select className="form-select"></select>;
            };        

        - Inside the JSX property <select>
            - Declare the four (4) categories using the JSX element <option>
            
            - NOTE: For now, these items are hard-coded

            const ExpenseFilter = () => {
                return (
                    <select className="form-select">
                        <option value="">All categories</option>
                        <option value="Groceries">Groceries</option>
                        <option value="Utilities">Utilities</option>
                        <option value="Entertainment">Entertainment</option>
                    </select>
                );
            };
                    

    - Define the "shape" of the Props using an interface
        - Declare the property "onSelect"
        - Set it with an anonymous arrow function

        - On the arrow function
            - Declare a paramter variable named "category"
            - Data type of "string"

        - Inside the arrow function
            - Returns "void"

        interface Props {
            onSelectCategory: (category: string) => void;
        }

    - On the component's function declaration
        - Pass Props as an argument value
        - Deconstruct the property "onSelectCategory"

        const ExpenseFilter = ({ onSelectCategory }: Props) => {
            return (
                ...
            );
        };
    
    - On the JSX element <select>
        - Declare the property "onChange"
        - Set it to an anonymous arrow function

        - On the arrow function
            - Declare a parameter variable named "event"

        - Inside the arrow function
            - Call the property "onSelectCategory()"
            - Pass "event.target.value" as an argument value to "onSelectCategory()"

            return (
                <select
                className="form-select"
                onChange={(event) => onSelectCategory(event.target.value)}
                >
                    ...
                </select>
            )


- Open the <App /> component (App.tsx)
    - Import the <ExpenseFilter /> component

        import ExpenseFilter from "./expense-list/components/ExpenseFilter";

    - On the component's JSX mark-up
        - Add the <ExpenseFilter /> component on top of the <ExpenseList /> component

        - Declare the property "onSelectCategory"
            - Set it to an anonymous arrow function

        - On the arrow function
            - Declare the parameter variable "category"

        - Inside the arrow function
            - Pass the value of the parameter variable "category" to "console.log()"

            return (
                <div>                    
                    <ExpenseFilter onSelectCategory={(category) => console.log(category)} />

                    <ExpenseList
                        expenses={expenses}
                        onDelete={(id) => setExpenses(expenses.filter((e) => e.id !== id))}
                    />
                </div>
            );

        - Save the changes
            - Vite reloads the React application

            - Renders both <ExpenseFilter /> and <ExpenseList /> components

            - When a category is selected from the <ExpenseFilter /> component
                - The chosen category is displayed on the browser's JavaScript console

            - NOTE: The <ExpenseFilter /> component is too close to the <ExpenseList /> component

        - To address this concern
            - Add some "margin" below the <ExpenseFilter /> component

            - Create a JSX element <div> above the <ExpenseFilter /> component
                - Declare the property "className"
                - Set it to Bootstrap's class "mb-3"
                - NOTE: This translates to CSS property "margin-bottom: 3px"

            - Then move the <ExpenseFilter /> component inside the JSX element <div>

            return (
                <div>
                    <div className="mb-3">
                        <ExpenseFilter onSelectCategory={(category) => console.log(category)} />
                    </div>

                    <ExpenseList
                        expenses={expenses}
                        onDelete={(id) => setExpenses(expenses.filter((e) => e.id !== id))}
                    />
                </div>
            );
        
        - Save the changes
            - Vite reloads the React application
            - Addresses the noted UI problem


    - Next is to work on filtering
        - Declare another State Hook
            - To create another state variable that stores the selected category (i.e. filter)

            - When the category changes
                - The <App /> component will re-render
                - The list inside <ExpenseList /> will be updated

        - Call the function "useState()"
            - Pass an argument value of empty string

        - Destructure the returned object
            - The state variable is named "selectedCategory"
            - The set/update function is named "setSelectedCategory"

            const [selectedCategory, setSelectedCategory] = useState("");

    - Move back to the component's JSX mark-up
        - On the <ExpenseFilter />

        - Refactor the arrow function assigned to the property "onSelectCategory"
            - Replace the call to "console.log()"
            - To the set function "setSelectedCategory()"
            - Pass the parameter variable "category" as an argument value to "setSelectedCategory()"

            <ExpenseFilter
                onSelectCategory={(category) => setSelectedCategory(category)}
            />


        - On the <ExpenseList />
            - Instead of passing the state variable "expenses" to the property "expenses"
                - Pass a non-existent "filtered list"

            - Outside the <App /> component's JSX mark-up
                - Declare a constant named "visibleExpenses"

                - Assign a ternary operator
                
                - Checks if the state variable "selectedCategory" is truthy
                    - It has an assigned value
                    - NOT its initial empty string (e.g. falsy)
                
                - If truthy
                    - Call the method ".filter()" on the state variable "expenses"
                        - Accepts a parameter variable "e" (i.e. individual expense / item)
                        - Check if the property "category" of "e" is equal to the value in the state variable "category"
                        - Returns a new array with "filtered" items
        
                - Otherwise
                    - Assign the value in state variable "expenses" to the constant "visibleExpenses"

                const visibleExpenses = selectedCategory
                    ? expenses.filter((e) => { e.category === selectedCategory }) : expenses;


            - Pass the constant "visibleExpenses" to the property "expenses"

            <ExpenseList
                expenses={visibleExpenses}
                onDelete={(id) => setExpenses(expenses.filter((e) => e.id !== id))}
             />

    - Save the changes
        - Vite reloads the React application

        - Selecting the category rendered by the <ExpenseFilter /> component
            - Filters the expenses rendered by the <ExpenseList /> component
