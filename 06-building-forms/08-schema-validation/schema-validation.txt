Schema-based Validation with Zod
--------------------------------
- Based on the previous code example
    - Form validation rules are implement within the JSX mark-up <input>
    
    - As the form gets more complex
        - The validation rules will be all over the place
        - To address this concern
            - Use a technique called "schema-based valiation"
 
    - Zod is one of the many 3rd-party libraries that
        - Allows to define all form validation rules in a single place (i.e. schema)


- To install Zod via npm

    npm i zod@3.20.6

    - In the event that Zod does NOT get included in the file "package.json"
        - Clear the npm cache
            
            npm cache clean --force

        - Try to install Zod again
        

- To define a schema for the project's form
    - Import the Zod library in the <Form /> component

        import { z } from "zod";

    - Use "z" to define the form's schema and all of its validation rules
        - Call the method ".object()" of z

        - Pass a "configuration object" as argument value to the method
            - This contains the properties that represents the form's fields
                - "name"    = of type "string" with a minimum number of characters of 3
                - "age"     = of type "number" with a minimum value of 18

        - The method ".object()" returns an object
            - Save the object to a constant named "schema"
            - "This object contains the form's schema"

                const schema = z.object({
                    name: z.string().min(3),
                    age: z.number().min(18),
                });

        - The chained methods ".string()" and ".min()" are referred as "helper method"
            - They help define validation rules in a form


    - Remove the previously defined FormData "interface"
        - Zod has a method ".infer" that allows to extract the data type from a schema object

    - Call method ".infer" followed by "<typeof schema>"
        - This returns a TypeScript "type"
        - A TypeScript "type" is very similar to a TypeScript "interface"
        - Store the returned object in a "type" named "FormData"

            type FormData = z.infer<typeof schema>;

        - Hovering the mouse over "FormData" previews the content of the returned object


- To integrate React Hook Forms with Zod
    - Install React HooK Forms' "resolvers" for various schema-based validation libraries

        npm i @hookform/resolvers@2.9.11

    - Import the resolver for the Zod library (i.e. zodResolver) in the <Form /> component

        import { zodResolver } from "@hookform/resolvers/zod";

    - When calling the Form Hook
        - Pass a configuration object as argument to "useForm<FormData>()"

        - In the configuration object
            - Assign the function "zodResolver()" as value to the property "resolver"
            - Pass the object "schema" as argument value to "zodResolver"

            const Form = () => {
                const {
                    register,
                    handleSubmit,
                    formState: { errors },
                } = useForm<FormData>({ resolver: zodResolver(schema) });
            ...
            }


- Consolidate error messages
    - Remove the embedded validation rules from the JSX <input> elements
        - Since all validation rules are defined within the schema

        - From:

        <input
            {...register("name", { required: true, minLength: 3 })}
            id="name"
            type="text"
            className="form-control"
        />

        - To:

        <input
            {...register("name")}
            id="name"
            type="text"
            className="form-control"
        />

    - Delete the 2nd JSX <p> element embedded within an object, containing the 2nd error message
        - There is NO need for separate <p> elements for error messages
        - Error messages will be stored in a single <p> element with dynamic content

            {errors.name?.type === "required" && (
                <p className="text-danger">The name field is required.</p>
            )}

            {/* DELETE THIS OBJECT */}
            {errors.name?.type === "minLength" && (
                <p className="text-danger">The name must be at least 3 characters.</p>
            )}
    
    - Simply the boolean expression of the 1st embedded <p> element within an object
        - There is NO longer the need to check for the type
        - Just for the existence of the property "name" in the "errors" object

        - From:

            {errors.name?.type === "required" && (
                <p className="text-danger">The name field is required.</p>
            )}

        - To:

            {errors.name && (
                <p className="text-danger">The name field is required.</p>
            )}

    - Instead of hard-coding the error message
        - Replace the hard-coded error message by passing an object containing "errors.name.message"
        - Instructs Zod to dynamically generate the error message based on the defined schema

            {errors.name && <p className="text-danger">{errors.name.message}</p>}

    - Copy the previous line of code to the next JSX <input> field representing the "age" field
        - Replace the property "name" with the property "age"

            {errors.age && <p className="text-danger">{errors.age.message}</p>}

    - Save changes and test code
        - Clicking the "submit" button
        - Displays the default error message for each field


- To define custom error message for each field
    - For the "name" field
        - In the "name" property of the defined schema
        
        - Pass an object as 2nd argument value in the ".min()" method

        - Inside the object, assign the custom error message to the property "message"

            const schema = z.object({
                name: z.string().min(3, { message: "Name must be at least 3 characters." }),
                age: z.number().min(18),
            });


    - For the "age" field
        - It returns the default message "Expected number, received string"
        
        - This is due to the fact that the JSX <input> element's attribute of "value"
            - ALWAYS returns a string value

        - To address this, instruct the React Hook Form
            - To have the JSX <input> element's attribute of "value" return a number instead

    - To implement this
        - In the function "register()" of the age field's JSX <input> element
        - Pass an object as a 2nd argument value
        - Inside the object, assign the boolean value of "true" to the property "valueAsNumber"

        <input
          {...register("age", { valueAsNumber: true })}
          id="age"
          type="number"
          className="form-control"
        />

    - Save changes and test code
        - The "age" field now returns the default error message "Expected number, received nan"
    
    - Define a custom error message
        - In the "age" property of the defined schema
        - Pass an object as an argument value to the method ".number()"
        - Inside the object, assign the custom error message to the property "invalid_type_error"

        const schema = z.object({
            name: z.string().min(3, { message: "Name must be at least 3 characters." }),
            age: z.number({ invalid_type_error: "Age field is required."}).min(18),
        });

    - Save changes and test code

    - Add an addition custom message for the "age" field
        - To inform the user that the expected minimum age is 18

    - Define the additional custom message
        - In the "age" property of the defined schema
        - Pass an object as a 2nd argument value to the method ".min()"
        - Inside the object, assign the custom error message to the property "message"

        const schema = z.object({
        name: z.string().min(3, { message: "Name must be at least 3 characters." }),
        age: z
            .number({ invalid_type_error: "Age field is required." })
            .min(18, { message: "Age must be at least 18." }),
        });

    - Save changes and test code